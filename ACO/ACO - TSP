import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import random

def distance(point1, point2):
    return np.sqrt(np.sum((point1 - point2)**2))

def update_speed(current_weight):
    return velocity_max - (current_weight / Q) * (velocity_max - velocity_min)


def cities_stolen(knapsack, assigned_nodes):
    if len(knapsack) != len(assigned_nodes):
        raise ValueError("Knapsack and assigned nodes must be of same length§")
    cities = {}
    item = 0
    for stolen,city in zip(knapsack,assigned_nodes):
        if stolen:
            if city in cities:
                cities[city].append(item)
            else:
                cities[city] = [item]
    return cities


def time(point1, point2,curr_weight, capacity):
    new_speed = update_speed(curr_weight)
    time = distance(point1,point2)
    
    

def ant_colony_optimization(points, n_ants, n_iterations, alpha, beta, evaporation_rate, Q):
    '''

    Parameters
    ------------
    points: list
        list of cities

    n_ants: int
        Number of ants included in colony

    n_iterations: int
        Number of iterations to run

    alpha: float
        weight on pheromones - higher emphasizes importance of pheromones
       
    beta: float
        weight on heuristic (distance, cost) - higher increase reliance of this info on ant decision making
        

    evaperation rate: float
        rate of pheromone evaporation

    Q: Float
        Amount of pheromone deposited - higher the Q, more substantial increase in pheromone levels on nodes visited


    Returns
    --------
    '''


    n_points = len(points)
    pheromone = np.ones((n_points, n_points))  # Inital array of pheromones - all set as one
    best_path = None
    best_path_length = np.inf                  
    
    for iteration in range(n_iterations):
        paths = []
        path_lengths = []
        
        for ant in range(n_ants):
            visited = [False]*n_points
            current_point = np.random.randint(n_points)     # Set initial point randomly
            visited[current_point] = True                   # Visited city tracker
            path = [current_point]
            path_length = 0
            
            while False in visited:        # Check all cities
                unvisited = np.where(np.logical_not(visited))[0]      # Unvisted city array
                probabilities = np.zeros(len(unvisited))              # Empty probability list of traversing to each unvisited city
                
                # Calculate the probabilites of traveling to each city
                for i, unvisited_point in enumerate(unvisited):
                    # Transition rule
                    probabilities[i] = pheromone[current_point, unvisited_point]**alpha / distance(points[current_point], points[unvisited_point])**beta
                
                probabilities /= np.sum(probabilities)
                
                next_point = np.random.choice(unvisited, p=probabilities) # Randomly select next city using the probabilities
                path.append(next_point)
                path_length += distance(points[current_point], points[next_point])
                visited[next_point] = True
                current_point = next_point
            
            paths.append(path)
            path_lengths.append(path_length)
            
            # Update best path 
            if path_length < best_path_length:
                best_path = path
                best_path_length = path_length
        
        pheromone *= evaporation_rate    # Update current pheromones
        
        # Calculate new pheromomnes
        for path, path_length in zip(paths, path_lengths): 
            for i in range(n_points-1):
                pheromone[path[i], path[i+1]] += Q/path_length  # Update pheromones on each city to city path
            pheromone[path[-1], path[0]] += Q/path_length       # Update pheromones on each city to city path



def distance(point1, point2):
    return np.sqrt(np.sum((point1 - point2)**2))

def update_speed(current_weight, velocity_max, velicity_min, Q):
    return velocity_max - (current_weight / Q) * (velocity_max - velocity_min)


def cities_stolen(knapsack, assigned_nodes):
    if len(knapsack) != len(assigned_nodes):
        raise ValueError("Knapsack and assigned nodes must be of same length§")
    cities = {}
    item = 1
    for stolen,city in zip(knapsack,assigned_nodes):
        if stolen:
            if city in cities:
                cities[city].append(item)
            else:
                cities[city] = [item]
    return cities


def time(point1, point2, knapsack, visited_cities,curr_weight):
    """
    This function returns the time it takes to get from point1 to point2 given the current weight of the knapsack and the distance between the two  
    """
    new_speed = update_speed(curr_weight)
    time = distance(point1,point2)
    

# Example usage:
n_ants = 100
n_iterations = 50000
alpha = 1
beta = 4
evaporation_rate = 0.2
Q = 1

for _ in range(5):
    results = pd.DataFrame()
    path, path_length  = ant_colony_optimization(matrix, n_ants=n_ants, n_iterations=n_iterations, alpha=alpha, beta=beta, evaporation_rate=evaporation_rate, Q=Q)

    # Create a dictionary with the collected data
    entry = {
        '# ants': n_ants,
        '# Iterations': n_iterations,
        'alpha': alpha,
        'beta': beta,
        'Evaporation Rate': evaporation_rate,
        'Q': Q,
        'Path': [path],
        'Path Length': [path_length]
    }

    # Append the entry to the list
    results_log.append(entry)

    # Concatenate the list of dictionaries into a DataFrame
    results = pd.concat([pd.DataFrame.from_dict(d) for d in results_log], ignore_index=True)
